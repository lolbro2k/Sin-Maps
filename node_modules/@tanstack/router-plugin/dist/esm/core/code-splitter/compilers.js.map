{"version":3,"file":"compilers.js","sources":["../../../../src/core/code-splitter/compilers.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport babel from '@babel/core'\nimport * as template from '@babel/template'\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n  generateFromAst,\n  parseAst,\n} from '@tanstack/router-utils'\nimport { tsrShared, tsrSplit } from '../constants'\nimport { routeHmrStatement } from '../route-hmr-statement'\nimport { createIdentifier } from './path-ids'\nimport { getFrameworkOptions } from './framework-options'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\nimport type { CodeSplitGroupings, SplitRouteIdentNodes } from '../constants'\nimport type { Config, DeletableNodes } from '../config'\n\ntype SplitNodeMeta = {\n  routeIdent: SplitRouteIdentNodes\n  splitStrategy: 'lazyFn' | 'lazyRouteComponent'\n  localImporterIdent: string\n  exporterIdent: string\n  localExporterIdent: string\n}\nconst SPLIT_NODES_CONFIG = new Map<SplitRouteIdentNodes, SplitNodeMeta>([\n  [\n    'loader',\n    {\n      routeIdent: 'loader',\n      localImporterIdent: '$$splitLoaderImporter', // const $$splitLoaderImporter = () => import('...')\n      splitStrategy: 'lazyFn',\n      localExporterIdent: 'SplitLoader', // const SplitLoader = ...\n      exporterIdent: 'loader', // export { SplitLoader as loader }\n    },\n  ],\n  [\n    'component',\n    {\n      routeIdent: 'component',\n      localImporterIdent: '$$splitComponentImporter', // const $$splitComponentImporter = () => import('...')\n      splitStrategy: 'lazyRouteComponent',\n      localExporterIdent: 'SplitComponent', // const SplitComponent = ...\n      exporterIdent: 'component', // export { SplitComponent as component }\n    },\n  ],\n  [\n    'pendingComponent',\n    {\n      routeIdent: 'pendingComponent',\n      localImporterIdent: '$$splitPendingComponentImporter', // const $$splitPendingComponentImporter = () => import('...')\n      splitStrategy: 'lazyRouteComponent',\n      localExporterIdent: 'SplitPendingComponent', // const SplitPendingComponent = ...\n      exporterIdent: 'pendingComponent', // export { SplitPendingComponent as pendingComponent }\n    },\n  ],\n  [\n    'errorComponent',\n    {\n      routeIdent: 'errorComponent',\n      localImporterIdent: '$$splitErrorComponentImporter', // const $$splitErrorComponentImporter = () => import('...')\n      splitStrategy: 'lazyRouteComponent',\n      localExporterIdent: 'SplitErrorComponent', // const SplitErrorComponent = ...\n      exporterIdent: 'errorComponent', // export { SplitErrorComponent as errorComponent }\n    },\n  ],\n  [\n    'notFoundComponent',\n    {\n      routeIdent: 'notFoundComponent',\n      localImporterIdent: '$$splitNotFoundComponentImporter', // const $$splitNotFoundComponentImporter = () => import('...')\n      splitStrategy: 'lazyRouteComponent',\n      localExporterIdent: 'SplitNotFoundComponent', // const SplitNotFoundComponent = ...\n      exporterIdent: 'notFoundComponent', // export { SplitNotFoundComponent as notFoundComponent }\n    },\n  ],\n])\nconst KNOWN_SPLIT_ROUTE_IDENTS = [...SPLIT_NODES_CONFIG.keys()] as const\n\nfunction addSplitSearchParamToFilename(\n  filename: string,\n  grouping: Array<string>,\n) {\n  const [bareFilename] = filename.split('?')\n\n  const params = new URLSearchParams()\n  params.append(tsrSplit, createIdentifier(grouping))\n\n  const result = `${bareFilename}?${params.toString()}`\n  return result\n}\n\nfunction removeSplitSearchParamFromFilename(filename: string) {\n  const [bareFilename] = filename.split('?')\n  return bareFilename!\n}\n\nexport function addSharedSearchParamToFilename(filename: string) {\n  const [bareFilename] = filename.split('?')\n  return `${bareFilename}?${tsrShared}=1`\n}\n\nconst splittableCreateRouteFns = ['createFileRoute']\nconst unsplittableCreateRouteFns = [\n  'createRootRoute',\n  'createRootRouteWithContext',\n]\nconst allCreateRouteFns = [\n  ...splittableCreateRouteFns,\n  ...unsplittableCreateRouteFns,\n]\n\n/**\n * Recursively walk an AST node and collect referenced identifier-like names.\n * Much cheaper than babel.traverse — no path/scope overhead.\n *\n * Notes:\n * - Uses @babel/types `isReferenced` to avoid collecting non-references like\n *   object keys, member expression properties, or binding identifiers.\n * - Also handles JSX identifiers for component references.\n */\nexport function collectIdentifiersFromNode(node: t.Node): Set<string> {\n  const ids = new Set<string>()\n\n  ;(function walk(\n    n: t.Node | null | undefined,\n    parent?: t.Node,\n    grandparent?: t.Node,\n    parentKey?: string,\n  ) {\n    if (!n) return\n\n    if (t.isIdentifier(n)) {\n      // When we don't have parent info (node passed in isolation), treat as referenced.\n      if (!parent || t.isReferenced(n, parent, grandparent)) {\n        ids.add(n.name)\n      }\n      return\n    }\n\n    if (t.isJSXIdentifier(n)) {\n      // Skip attribute names: <div data-testid=\"x\" />\n      if (parent && t.isJSXAttribute(parent) && parentKey === 'name') {\n        return\n      }\n\n      // Skip member properties: <Foo.Bar /> should count Foo, not Bar\n      if (\n        parent &&\n        t.isJSXMemberExpression(parent) &&\n        parentKey === 'property'\n      ) {\n        return\n      }\n\n      // Intrinsic elements (lowercase) are not identifiers\n      const first = n.name[0]\n      if (first && first === first.toLowerCase()) {\n        return\n      }\n\n      ids.add(n.name)\n      return\n    }\n\n    for (const key of t.VISITOR_KEYS[n.type] || []) {\n      const child = (n as any)[key]\n      if (Array.isArray(child)) {\n        for (const c of child) {\n          if (c && typeof c.type === 'string') {\n            walk(c, n, parent, key)\n          }\n        }\n      } else if (child && typeof child.type === 'string') {\n        walk(child, n, parent, key)\n      }\n    }\n  })(node)\n\n  return ids\n}\n\n/**\n * Build a map from binding name → declaration AST node for all\n * locally-declared module-level bindings. Built once, O(1) lookup.\n */\nexport function buildDeclarationMap(ast: t.File): Map<string, t.Node> {\n  const map = new Map<string, t.Node>()\n  for (const stmt of ast.program.body) {\n    const decl =\n      t.isExportNamedDeclaration(stmt) && stmt.declaration\n        ? stmt.declaration\n        : stmt\n\n    if (t.isVariableDeclaration(decl)) {\n      for (const declarator of decl.declarations) {\n        for (const name of collectIdentifiersFromPattern(declarator.id)) {\n          map.set(name, declarator)\n        }\n      }\n    } else if (t.isFunctionDeclaration(decl) && decl.id) {\n      map.set(decl.id.name, decl)\n    } else if (t.isClassDeclaration(decl) && decl.id) {\n      map.set(decl.id.name, decl)\n    }\n  }\n  return map\n}\n\n/**\n * Build a dependency graph: for each local binding, the set of other local\n * bindings its declaration references. Built once via simple node walking.\n */\nexport function buildDependencyGraph(\n  declMap: Map<string, t.Node>,\n  localBindings: Set<string>,\n): Map<string, Set<string>> {\n  const graph = new Map<string, Set<string>>()\n  for (const [name, declNode] of declMap) {\n    if (!localBindings.has(name)) continue\n    const allIds = collectIdentifiersFromNode(declNode)\n    const deps = new Set<string>()\n    for (const id of allIds) {\n      if (id !== name && localBindings.has(id)) deps.add(id)\n    }\n    graph.set(name, deps)\n  }\n  return graph\n}\n\n/**\n * Computes module-level bindings that are shared between split and non-split\n * route properties. These bindings need to be extracted into a shared virtual\n * module to avoid double-initialization.\n *\n * A binding is \"shared\" if it is referenced by at least one split property\n * AND at least one non-split property. Only locally-declared module-level\n * bindings are candidates (not imports — bundlers dedupe those).\n */\nexport function computeSharedBindings(opts: {\n  code: string\n  codeSplitGroupings: CodeSplitGroupings\n}): Set<string> {\n  const ast = parseAst(opts)\n\n  // Early bailout: collect all module-level locally-declared binding names.\n  // This is a cheap loop over program.body (no traversal). If the file has\n  // no local bindings (aside from `Route`), nothing can be shared — skip\n  // the expensive babel.traverse entirely.\n  const localModuleLevelBindings = new Set<string>()\n  for (const node of ast.program.body) {\n    collectLocalBindingsFromStatement(node, localModuleLevelBindings)\n  }\n\n  // File-based routes always export a route config binding (usually `Route`).\n  // This must never be extracted into the shared module.\n  localModuleLevelBindings.delete('Route')\n\n  if (localModuleLevelBindings.size === 0) {\n    return new Set()\n  }\n\n  function findIndexForSplitNode(str: string) {\n    return opts.codeSplitGroupings.findIndex((group) =>\n      group.includes(str as any),\n    )\n  }\n\n  // Find the route options object — needs babel.traverse for scope resolution\n  let routeOptions: t.ObjectExpression | undefined\n\n  babel.traverse(ast, {\n    CallExpression(path) {\n      if (!t.isIdentifier(path.node.callee)) return\n      if (!splittableCreateRouteFns.includes(path.node.callee.name)) return\n\n      if (t.isCallExpression(path.parentPath.node)) {\n        const opts = resolveIdentifier(path, path.parentPath.node.arguments[0])\n        if (t.isObjectExpression(opts)) routeOptions = opts\n      } else if (t.isVariableDeclarator(path.parentPath.node)) {\n        const caller = resolveIdentifier(path, path.parentPath.node.init)\n        if (t.isCallExpression(caller)) {\n          const opts = resolveIdentifier(path, caller.arguments[0])\n          if (t.isObjectExpression(opts)) routeOptions = opts\n        }\n      }\n    },\n  })\n\n  if (!routeOptions) return new Set()\n\n  // Fast path: if fewer than 2 distinct groups are referenced by route options,\n  // nothing can be shared and we can skip the rest of the work.\n  const splitGroupsPresent = new Set<number>()\n  let hasNonSplit = false\n  for (const prop of routeOptions.properties) {\n    if (!t.isObjectProperty(prop) || !t.isIdentifier(prop.key)) continue\n    if (prop.key.name === 'codeSplitGroupings') continue\n    if (t.isIdentifier(prop.value) && prop.value.name === 'undefined') continue\n    const groupIndex = findIndexForSplitNode(prop.key.name) // -1 if non-split\n    if (groupIndex === -1) {\n      hasNonSplit = true\n    } else {\n      splitGroupsPresent.add(groupIndex)\n    }\n  }\n\n  if (!hasNonSplit && splitGroupsPresent.size < 2) return new Set()\n\n  // Build dependency graph up front — needed for transitive expansion per-property.\n  // This graph excludes `Route` (deleted above) so group attribution works correctly.\n  const declMap = buildDeclarationMap(ast)\n  const depGraph = buildDependencyGraph(declMap, localModuleLevelBindings)\n\n  // Build a second dependency graph that includes `Route` so we can detect\n  // bindings that transitively depend on it. Such bindings must NOT be\n  // extracted into the shared module because they would drag the Route\n  // singleton with them, duplicating it across modules.\n  const allLocalBindings = new Set(localModuleLevelBindings)\n  allLocalBindings.add('Route')\n  const fullDepGraph = buildDependencyGraph(declMap, allLocalBindings)\n\n  // For each route property, track which \"group\" it belongs to.\n  // Non-split properties get group index -1.\n  // Split properties get their codeSplitGroupings index (0, 1, ...).\n  // A binding is \"shared\" if it appears in 2+ distinct groups.\n  // We expand each property's refs transitively BEFORE comparing groups,\n  // so indirect refs (e.g., component: MyComp where MyComp uses `shared`)\n  // are correctly attributed.\n  const refsByGroup = new Map<string, Set<number>>()\n\n  for (const prop of routeOptions.properties) {\n    if (!t.isObjectProperty(prop) || !t.isIdentifier(prop.key)) continue\n    const key = prop.key.name\n\n    if (key === 'codeSplitGroupings') continue\n\n    const groupIndex = findIndexForSplitNode(key) // -1 if non-split\n\n    const directRefs = collectModuleLevelRefsFromNode(\n      prop.value,\n      localModuleLevelBindings,\n    )\n\n    // Expand transitively: if component references SharedComp which references\n    // `shared`, then `shared` is also attributed to component's group.\n    const allRefs = new Set(directRefs)\n    expandTransitively(allRefs, depGraph)\n\n    for (const ref of allRefs) {\n      let groups = refsByGroup.get(ref)\n      if (!groups) {\n        groups = new Set()\n        refsByGroup.set(ref, groups)\n      }\n      groups.add(groupIndex)\n    }\n  }\n\n  // Shared = bindings appearing in 2+ distinct groups\n  const shared = new Set<string>()\n  for (const [name, groups] of refsByGroup) {\n    if (groups.size >= 2) shared.add(name)\n  }\n\n  // Destructured declarators (e.g. `const { a, b } = fn()`) must be treated\n  // as a single initialization unit. Even if each binding is referenced by\n  // only one group, if *different* bindings from the same declarator are\n  // referenced by different groups, the declarator must be extracted to the\n  // shared module to avoid double initialization.\n  expandSharedDestructuredDeclarators(ast, refsByGroup, shared)\n\n  if (shared.size === 0) return shared\n\n  // If any binding from a destructured declaration is shared,\n  // all bindings from that declaration must be shared\n  expandDestructuredDeclarations(ast, shared)\n\n  // Remove shared bindings that transitively depend on `Route`.\n  // The Route singleton must stay in the reference file; extracting a\n  // binding that references it would duplicate Route in the shared module.\n  removeBindingsDependingOnRoute(shared, fullDepGraph)\n\n  return shared\n}\n\n/**\n * If bindings from the same destructured declarator are referenced by\n * different groups, mark all bindings from that declarator as shared.\n */\nexport function expandSharedDestructuredDeclarators(\n  ast: t.File,\n  refsByGroup: Map<string, Set<number>>,\n  shared: Set<string>,\n) {\n  for (const stmt of ast.program.body) {\n    const decl =\n      t.isExportNamedDeclaration(stmt) && stmt.declaration\n        ? stmt.declaration\n        : stmt\n\n    if (!t.isVariableDeclaration(decl)) continue\n\n    for (const declarator of decl.declarations) {\n      if (!t.isObjectPattern(declarator.id) && !t.isArrayPattern(declarator.id))\n        continue\n\n      const names = collectIdentifiersFromPattern(declarator.id)\n\n      const usedGroups = new Set<number>()\n      for (const name of names) {\n        const groups = refsByGroup.get(name)\n        if (!groups) continue\n        for (const g of groups) usedGroups.add(g)\n      }\n\n      if (usedGroups.size >= 2) {\n        for (const name of names) {\n          shared.add(name)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Collect locally-declared module-level binding names from a statement.\n * Pure node inspection, no traversal.\n */\nexport function collectLocalBindingsFromStatement(\n  node: t.Statement | t.ModuleDeclaration,\n  bindings: Set<string>,\n) {\n  const decl =\n    t.isExportNamedDeclaration(node) && node.declaration\n      ? node.declaration\n      : node\n\n  if (t.isVariableDeclaration(decl)) {\n    for (const declarator of decl.declarations) {\n      for (const name of collectIdentifiersFromPattern(declarator.id)) {\n        bindings.add(name)\n      }\n    }\n  } else if (t.isFunctionDeclaration(decl) && decl.id) {\n    bindings.add(decl.id.name)\n  } else if (t.isClassDeclaration(decl) && decl.id) {\n    bindings.add(decl.id.name)\n  }\n}\n\n/**\n * Collect direct module-level binding names referenced from a given AST node.\n * Uses a simple recursive walk instead of babel.traverse.\n */\nexport function collectModuleLevelRefsFromNode(\n  node: t.Node,\n  localModuleLevelBindings: Set<string>,\n): Set<string> {\n  const allIds = collectIdentifiersFromNode(node)\n  const refs = new Set<string>()\n  for (const name of allIds) {\n    if (localModuleLevelBindings.has(name)) refs.add(name)\n  }\n  return refs\n}\n\n/**\n * Expand the shared set transitively using a prebuilt dependency graph.\n * No AST traversals — pure graph BFS.\n */\nexport function expandTransitively(\n  shared: Set<string>,\n  depGraph: Map<string, Set<string>>,\n) {\n  const queue = [...shared]\n  const visited = new Set<string>()\n\n  while (queue.length > 0) {\n    const name = queue.pop()!\n    if (visited.has(name)) continue\n    visited.add(name)\n\n    const deps = depGraph.get(name)\n    if (!deps) continue\n\n    for (const dep of deps) {\n      if (!shared.has(dep)) {\n        shared.add(dep)\n        queue.push(dep)\n      }\n    }\n  }\n}\n\n/**\n * Remove any bindings from `shared` that transitively depend on `Route`.\n * The Route singleton must remain in the reference file; if a shared binding\n * references it (directly or transitively), extracting that binding would\n * duplicate Route in the shared module.\n *\n * Uses `depGraph` which must include `Route` as a node so the dependency\n * chain is visible.\n */\nexport function removeBindingsDependingOnRoute(\n  shared: Set<string>,\n  depGraph: Map<string, Set<string>>,\n) {\n  const reverseGraph = new Map<string, Set<string>>()\n  for (const [name, deps] of depGraph) {\n    for (const dep of deps) {\n      let parents = reverseGraph.get(dep)\n      if (!parents) {\n        parents = new Set<string>()\n        reverseGraph.set(dep, parents)\n      }\n      parents.add(name)\n    }\n  }\n\n  // Walk backwards from Route to find all bindings that can reach it.\n  const visited = new Set<string>()\n  const queue = ['Route']\n  while (queue.length > 0) {\n    const cur = queue.pop()!\n    if (visited.has(cur)) continue\n    visited.add(cur)\n\n    const parents = reverseGraph.get(cur)\n    if (!parents) continue\n    for (const parent of parents) {\n      if (!visited.has(parent)) queue.push(parent)\n    }\n  }\n\n  for (const name of [...shared]) {\n    if (visited.has(name)) {\n      shared.delete(name)\n    }\n  }\n}\n\n/**\n * If any binding from a destructured declaration is shared,\n * ensure all bindings from that same declaration are also shared.\n * Pure node inspection of program.body, no traversal.\n */\nexport function expandDestructuredDeclarations(\n  ast: t.File,\n  shared: Set<string>,\n) {\n  for (const stmt of ast.program.body) {\n    const decl =\n      t.isExportNamedDeclaration(stmt) && stmt.declaration\n        ? stmt.declaration\n        : stmt\n\n    if (!t.isVariableDeclaration(decl)) continue\n\n    for (const declarator of decl.declarations) {\n      if (!t.isObjectPattern(declarator.id) && !t.isArrayPattern(declarator.id))\n        continue\n\n      const names = collectIdentifiersFromPattern(declarator.id)\n      const hasShared = names.some((n) => shared.has(n))\n      if (hasShared) {\n        for (const n of names) {\n          shared.add(n)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Find which shared bindings are user-exported in the original source.\n * These need to be re-exported from the shared module.\n */\nfunction findExportedSharedBindings(\n  ast: t.File,\n  sharedBindings: Set<string>,\n): Set<string> {\n  const exported = new Set<string>()\n  for (const stmt of ast.program.body) {\n    if (!t.isExportNamedDeclaration(stmt) || !stmt.declaration) continue\n\n    if (t.isVariableDeclaration(stmt.declaration)) {\n      for (const decl of stmt.declaration.declarations) {\n        for (const name of collectIdentifiersFromPattern(decl.id)) {\n          if (sharedBindings.has(name)) exported.add(name)\n        }\n      }\n    } else if (\n      t.isFunctionDeclaration(stmt.declaration) &&\n      stmt.declaration.id\n    ) {\n      if (sharedBindings.has(stmt.declaration.id.name))\n        exported.add(stmt.declaration.id.name)\n    } else if (t.isClassDeclaration(stmt.declaration) && stmt.declaration.id) {\n      if (sharedBindings.has(stmt.declaration.id.name))\n        exported.add(stmt.declaration.id.name)\n    }\n  }\n  return exported\n}\n\n/**\n * Remove declarations of shared bindings from the AST.\n * Handles both plain and exported declarations, including destructured patterns.\n * Removes the entire statement if all bindings in it are shared.\n */\nfunction removeSharedDeclarations(ast: t.File, sharedBindings: Set<string>) {\n  ast.program.body = ast.program.body.filter((stmt) => {\n    const decl =\n      t.isExportNamedDeclaration(stmt) && stmt.declaration\n        ? stmt.declaration\n        : stmt\n\n    if (t.isVariableDeclaration(decl)) {\n      // Filter out declarators where all bound names are shared\n      decl.declarations = decl.declarations.filter((declarator) => {\n        const names = collectIdentifiersFromPattern(declarator.id)\n        return !names.every((n) => sharedBindings.has(n))\n      })\n      // If no declarators remain, remove the entire statement\n      if (decl.declarations.length === 0) return false\n    } else if (t.isFunctionDeclaration(decl) && decl.id) {\n      if (sharedBindings.has(decl.id.name)) return false\n    } else if (t.isClassDeclaration(decl) && decl.id) {\n      if (sharedBindings.has(decl.id.name)) return false\n    }\n\n    return true\n  })\n}\n\nexport function compileCodeSplitReferenceRoute(\n  opts: ParseAstOptions & {\n    codeSplitGroupings: CodeSplitGroupings\n    deleteNodes?: Set<DeletableNodes>\n    targetFramework: Config['target']\n    filename: string\n    id: string\n    addHmr?: boolean\n    sharedBindings?: Set<string>\n  },\n): GeneratorResult | null {\n  const ast = parseAst(opts)\n\n  const refIdents = findReferencedIdentifiers(ast)\n\n  const knownExportedIdents = new Set<string>()\n\n  function findIndexForSplitNode(str: string) {\n    return opts.codeSplitGroupings.findIndex((group) =>\n      group.includes(str as any),\n    )\n  }\n\n  const frameworkOptions = getFrameworkOptions(opts.targetFramework)\n  const PACKAGE = frameworkOptions.package\n  const LAZY_ROUTE_COMPONENT_IDENT = frameworkOptions.idents.lazyRouteComponent\n  const LAZY_FN_IDENT = frameworkOptions.idents.lazyFn\n\n  let createRouteFn: string\n\n  let modified = false as boolean\n  let hmrAdded = false as boolean\n  let sharedExportedNames: Set<string> | undefined\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath) {\n        /**\n         * If the component for the route is being imported from\n         * another file, this is to track the path to that file\n         * the path itself doesn't matter, we just need to keep\n         * track of it so that we can remove it from the imports\n         * list if it's not being used like:\n         *\n         * `import '../shared/imported'`\n         */\n        const removableImportPaths = new Set<string>([])\n\n        programPath.traverse({\n          CallExpression: (path) => {\n            if (!t.isIdentifier(path.node.callee)) {\n              return\n            }\n\n            if (!allCreateRouteFns.includes(path.node.callee.name)) {\n              return\n            }\n\n            createRouteFn = path.node.callee.name\n\n            function babelHandleReference(routeOptions: t.Node | undefined) {\n              const hasImportedOrDefinedIdentifier = (name: string) => {\n                return programPath.scope.hasBinding(name)\n              }\n\n              if (t.isObjectExpression(routeOptions)) {\n                if (opts.deleteNodes && opts.deleteNodes.size > 0) {\n                  routeOptions.properties = routeOptions.properties.filter(\n                    (prop) => {\n                      if (t.isObjectProperty(prop)) {\n                        if (t.isIdentifier(prop.key)) {\n                          if (opts.deleteNodes!.has(prop.key.name as any)) {\n                            modified = true\n                            return false\n                          }\n                        }\n                      }\n                      return true\n                    },\n                  )\n                }\n                if (!splittableCreateRouteFns.includes(createRouteFn)) {\n                  // we can't split this route but we still add HMR handling if enabled\n                  if (opts.addHmr && !hmrAdded) {\n                    programPath.pushContainer('body', routeHmrStatement)\n                    modified = true\n                    hmrAdded = true\n                  }\n                  // exit traversal so this route is not split\n                  return programPath.stop()\n                }\n                routeOptions.properties.forEach((prop) => {\n                  if (t.isObjectProperty(prop)) {\n                    if (t.isIdentifier(prop.key)) {\n                      const key = prop.key.name\n\n                      // If the user has not specified a split grouping for this key\n                      // then we should not split it\n                      const codeSplitGroupingByKey = findIndexForSplitNode(key)\n                      if (codeSplitGroupingByKey === -1) {\n                        return\n                      }\n                      const codeSplitGroup = [\n                        ...new Set(\n                          opts.codeSplitGroupings[codeSplitGroupingByKey],\n                        ),\n                      ]\n\n                      // find key in nodeSplitConfig\n                      const isNodeConfigAvailable = SPLIT_NODES_CONFIG.has(\n                        key as any,\n                      )\n\n                      if (!isNodeConfigAvailable) {\n                        return\n                      }\n\n                      // Exit early if the value is a boolean, null, or undefined.\n                      // These values mean \"don't use this component, fallback to parent\"\n                      // No code splitting needed to preserve fallback behavior\n                      if (\n                        t.isBooleanLiteral(prop.value) ||\n                        t.isNullLiteral(prop.value) ||\n                        (t.isIdentifier(prop.value) &&\n                          prop.value.name === 'undefined')\n                      ) {\n                        return\n                      }\n\n                      const splitNodeMeta = SPLIT_NODES_CONFIG.get(key as any)!\n\n                      // We need to extract the existing search params from the filename, if any\n                      // and add the relevant codesplitPrefix to them, then write them back to the filename\n                      const splitUrl = addSplitSearchParamToFilename(\n                        opts.filename,\n                        codeSplitGroup,\n                      )\n\n                      if (\n                        splitNodeMeta.splitStrategy === 'lazyRouteComponent'\n                      ) {\n                        const value = prop.value\n\n                        let shouldSplit = true\n\n                        if (t.isIdentifier(value)) {\n                          const existingImportPath =\n                            getImportSpecifierAndPathFromLocalName(\n                              programPath,\n                              value.name,\n                            ).path\n                          if (existingImportPath) {\n                            removableImportPaths.add(existingImportPath)\n                          }\n\n                          // exported identifiers should not be split\n                          // since they are already being imported\n                          // and need to be retained in the compiled file\n                          const isExported = hasExport(ast, value)\n                          if (isExported) {\n                            knownExportedIdents.add(value.name)\n                          }\n                          shouldSplit = !isExported\n\n                          if (shouldSplit) {\n                            removeIdentifierLiteral(path, value)\n                          }\n                        }\n\n                        if (!shouldSplit) {\n                          return\n                        }\n\n                        modified = true\n\n                        // Prepend the import statement to the program along with the importer function\n                        // Check to see if lazyRouteComponent is already imported before attempting\n                        // to import it again\n                        if (\n                          !hasImportedOrDefinedIdentifier(\n                            LAZY_ROUTE_COMPONENT_IDENT,\n                          )\n                        ) {\n                          programPath.unshiftContainer('body', [\n                            template.statement(\n                              `import { ${LAZY_ROUTE_COMPONENT_IDENT} } from '${PACKAGE}'`,\n                            )(),\n                          ])\n                        }\n\n                        // Check to see if the importer function is already defined\n                        // If not, define it with the dynamic import statement\n                        if (\n                          !hasImportedOrDefinedIdentifier(\n                            splitNodeMeta.localImporterIdent,\n                          )\n                        ) {\n                          programPath.unshiftContainer('body', [\n                            template.statement(\n                              `const ${splitNodeMeta.localImporterIdent} = () => import('${splitUrl}')`,\n                            )(),\n                          ])\n                        }\n\n                        prop.value = template.expression(\n                          `${LAZY_ROUTE_COMPONENT_IDENT}(${splitNodeMeta.localImporterIdent}, '${splitNodeMeta.exporterIdent}')`,\n                        )()\n\n                        // add HMR handling\n                        if (opts.addHmr && !hmrAdded) {\n                          programPath.pushContainer('body', routeHmrStatement)\n                          modified = true\n                          hmrAdded = true\n                        }\n                      } else {\n                        // if (splitNodeMeta.splitStrategy === 'lazyFn') {\n                        const value = prop.value\n\n                        let shouldSplit = true\n\n                        if (t.isIdentifier(value)) {\n                          const existingImportPath =\n                            getImportSpecifierAndPathFromLocalName(\n                              programPath,\n                              value.name,\n                            ).path\n                          if (existingImportPath) {\n                            removableImportPaths.add(existingImportPath)\n                          }\n\n                          // exported identifiers should not be split\n                          // since they are already being imported\n                          // and need to be retained in the compiled file\n                          const isExported = hasExport(ast, value)\n                          if (isExported) {\n                            knownExportedIdents.add(value.name)\n                          }\n                          shouldSplit = !isExported\n\n                          if (shouldSplit) {\n                            removeIdentifierLiteral(path, value)\n                          }\n                        }\n\n                        if (!shouldSplit) {\n                          return\n                        }\n                        modified = true\n\n                        // Prepend the import statement to the program along with the importer function\n                        if (!hasImportedOrDefinedIdentifier(LAZY_FN_IDENT)) {\n                          programPath.unshiftContainer(\n                            'body',\n                            template.smart(\n                              `import { ${LAZY_FN_IDENT} } from '${PACKAGE}'`,\n                            )(),\n                          )\n                        }\n\n                        // Check to see if the importer function is already defined\n                        // If not, define it with the dynamic import statement\n                        if (\n                          !hasImportedOrDefinedIdentifier(\n                            splitNodeMeta.localImporterIdent,\n                          )\n                        ) {\n                          programPath.unshiftContainer('body', [\n                            template.statement(\n                              `const ${splitNodeMeta.localImporterIdent} = () => import('${splitUrl}')`,\n                            )(),\n                          ])\n                        }\n\n                        // Add the lazyFn call with the dynamic import to the prop value\n                        prop.value = template.expression(\n                          `${LAZY_FN_IDENT}(${splitNodeMeta.localImporterIdent}, '${splitNodeMeta.exporterIdent}')`,\n                        )()\n                      }\n                    }\n                  }\n\n                  programPath.scope.crawl()\n                })\n              }\n            }\n\n            if (t.isCallExpression(path.parentPath.node)) {\n              // createFileRoute('/')({ ... })\n              const options = resolveIdentifier(\n                path,\n                path.parentPath.node.arguments[0],\n              )\n\n              babelHandleReference(options)\n            } else if (t.isVariableDeclarator(path.parentPath.node)) {\n              // createFileRoute({ ... })\n              const caller = resolveIdentifier(path, path.parentPath.node.init)\n\n              if (t.isCallExpression(caller)) {\n                const options = resolveIdentifier(path, caller.arguments[0])\n                babelHandleReference(options)\n              }\n            }\n          },\n        })\n\n        /**\n         * If the component for the route is being imported,\n         * and it's not being used, remove the import statement\n         * from the program, by checking that the import has no\n         * specifiers\n         */\n        if (removableImportPaths.size > 0) {\n          modified = true\n          programPath.traverse({\n            ImportDeclaration(path) {\n              if (path.node.specifiers.length > 0) return\n              if (removableImportPaths.has(path.node.source.value)) {\n                path.remove()\n              }\n            },\n          })\n        }\n\n        // Handle shared bindings inside the Program visitor so we have\n        // access to programPath for cheap refIdents registration.\n        if (opts.sharedBindings && opts.sharedBindings.size > 0) {\n          sharedExportedNames = findExportedSharedBindings(\n            ast,\n            opts.sharedBindings,\n          )\n          removeSharedDeclarations(ast, opts.sharedBindings)\n\n          const sharedModuleUrl = addSharedSearchParamToFilename(opts.filename)\n\n          const sharedImportSpecifiers = [...opts.sharedBindings].map((name) =>\n            t.importSpecifier(t.identifier(name), t.identifier(name)),\n          )\n          const [sharedImportPath] = programPath.unshiftContainer(\n            'body',\n            t.importDeclaration(\n              sharedImportSpecifiers,\n              t.stringLiteral(sharedModuleUrl),\n            ),\n          )\n\n          // Register import specifier locals in refIdents so DCE can remove unused ones\n          sharedImportPath.traverse({\n            Identifier(identPath) {\n              if (\n                identPath.parentPath.isImportSpecifier() &&\n                identPath.key === 'local'\n              ) {\n                refIdents.add(identPath)\n              }\n            },\n          })\n\n          // Re-export user-exported shared bindings from the shared module\n          if (sharedExportedNames.size > 0) {\n            const reExportSpecifiers = [...sharedExportedNames].map((name) =>\n              t.exportSpecifier(t.identifier(name), t.identifier(name)),\n            )\n            programPath.pushContainer(\n              'body',\n              t.exportNamedDeclaration(\n                null,\n                reExportSpecifiers,\n                t.stringLiteral(sharedModuleUrl),\n              ),\n            )\n          }\n        }\n      },\n    },\n  })\n\n  if (!modified) {\n    return null\n  }\n\n  deadCodeElimination(ast, refIdents)\n\n  // if there are exported identifiers, then we need to add a warning\n  // to the file to let the user know that the exported identifiers\n  // will not in the split file but in the original file, therefore\n  // increasing the bundle size\n  if (knownExportedIdents.size > 0) {\n    const warningMessage = createNotExportableMessage(\n      opts.filename,\n      knownExportedIdents,\n    )\n    console.warn(warningMessage)\n\n    // append this warning to the file using a template\n    if (process.env.NODE_ENV !== 'production') {\n      const warningTemplate = template.statement(\n        `console.warn(${JSON.stringify(warningMessage)})`,\n      )()\n      ast.program.body.unshift(warningTemplate)\n    }\n  }\n\n  const result = generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n\n  // @babel/generator does not populate sourcesContent because it only has\n  // the AST, not the original text.  Without this, Vite's composed\n  // sourcemap omits the original source, causing downstream consumers\n  // (e.g. import-protection snippet display) to fall back to the shorter\n  // compiled output and fail to resolve original line numbers.\n  if (result.map) {\n    result.map.sourcesContent = [opts.code]\n  }\n\n  return result\n}\n\nexport function compileCodeSplitVirtualRoute(\n  opts: ParseAstOptions & {\n    splitTargets: Array<SplitRouteIdentNodes>\n    filename: string\n    sharedBindings?: Set<string>\n  },\n): GeneratorResult {\n  const ast = parseAst(opts)\n  const refIdents = findReferencedIdentifiers(ast)\n\n  // Remove shared declarations BEFORE babel.traverse so the scope never sees\n  // conflicting bindings (avoids checkBlockScopedCollisions crash in DCE)\n  if (opts.sharedBindings && opts.sharedBindings.size > 0) {\n    removeSharedDeclarations(ast, opts.sharedBindings)\n  }\n\n  const intendedSplitNodes = new Set(opts.splitTargets)\n\n  const knownExportedIdents = new Set<string>()\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath) {\n        const trackedNodesToSplitByType: Record<\n          SplitRouteIdentNodes,\n          { node: t.Node | undefined; meta: SplitNodeMeta } | undefined\n        > = {\n          component: undefined,\n          loader: undefined,\n          pendingComponent: undefined,\n          errorComponent: undefined,\n          notFoundComponent: undefined,\n        }\n\n        // Find and track all the known split-able nodes\n        programPath.traverse({\n          CallExpression: (path) => {\n            if (!t.isIdentifier(path.node.callee)) {\n              return\n            }\n\n            if (!splittableCreateRouteFns.includes(path.node.callee.name)) {\n              return\n            }\n\n            function babelHandleVirtual(options: t.Node | undefined) {\n              if (t.isObjectExpression(options)) {\n                options.properties.forEach((prop) => {\n                  if (t.isObjectProperty(prop)) {\n                    // do not use `intendedSplitNodes` here\n                    // since we have special considerations that need\n                    // to be accounted for like (not splitting exported identifiers)\n                    KNOWN_SPLIT_ROUTE_IDENTS.forEach((splitType) => {\n                      if (\n                        !t.isIdentifier(prop.key) ||\n                        prop.key.name !== splitType\n                      ) {\n                        return\n                      }\n\n                      const value = prop.value\n\n                      // If the value for the `key` is `undefined`, then we don't need to include it\n                      // in the split file, so we can just return, since it will kept in-place in the\n                      // reference file\n                      // This is useful for cases like: `createFileRoute('/')({ component: undefined })`\n                      if (t.isIdentifier(value) && value.name === 'undefined') {\n                        return\n                      }\n\n                      let isExported = false\n                      if (t.isIdentifier(value)) {\n                        isExported = hasExport(ast, value)\n                        if (isExported) {\n                          knownExportedIdents.add(value.name)\n                        }\n                      }\n\n                      // If the node is exported, we need to remove\n                      // the export from the split file\n                      if (isExported && t.isIdentifier(value)) {\n                        removeExports(ast, value)\n                      } else {\n                        const meta = SPLIT_NODES_CONFIG.get(splitType)!\n                        trackedNodesToSplitByType[splitType] = {\n                          node: prop.value,\n                          meta,\n                        }\n                      }\n                    })\n                  }\n                })\n\n                // Remove all of the options\n                options.properties = []\n              }\n            }\n\n            if (t.isCallExpression(path.parentPath.node)) {\n              // createFileRoute('/')({ ... })\n              const options = resolveIdentifier(\n                path,\n                path.parentPath.node.arguments[0],\n              )\n\n              babelHandleVirtual(options)\n            } else if (t.isVariableDeclarator(path.parentPath.node)) {\n              // createFileRoute({ ... })\n              const caller = resolveIdentifier(path, path.parentPath.node.init)\n\n              if (t.isCallExpression(caller)) {\n                const options = resolveIdentifier(path, caller.arguments[0])\n                babelHandleVirtual(options)\n              }\n            }\n          },\n        })\n\n        // Start the transformation to only exported the intended split nodes\n        intendedSplitNodes.forEach((SPLIT_TYPE) => {\n          const splitKey = trackedNodesToSplitByType[SPLIT_TYPE]\n\n          if (!splitKey) {\n            return\n          }\n\n          let splitNode = splitKey.node\n          const splitMeta = { ...splitKey.meta, shouldRemoveNode: true }\n\n          // Track the original identifier name before resolving through bindings,\n          // needed for destructured patterns where the binding resolves to the\n          // entire VariableDeclarator (ObjectPattern) rather than the specific binding\n          let originalIdentName: string | undefined\n          if (t.isIdentifier(splitNode)) {\n            originalIdentName = splitNode.name\n          }\n\n          while (t.isIdentifier(splitNode)) {\n            const binding = programPath.scope.getBinding(splitNode.name)\n            splitNode = binding?.path.node\n          }\n\n          // Add the node to the program\n          if (splitNode) {\n            if (t.isFunctionDeclaration(splitNode)) {\n              // an anonymous function declaration should only happen for `export default function() {...}`\n              // so we should never get here\n              if (!splitNode.id) {\n                throw new Error(\n                  `Function declaration for \"${SPLIT_TYPE}\" must have an identifier.`,\n                )\n              }\n              splitMeta.shouldRemoveNode = false\n              splitMeta.localExporterIdent = splitNode.id.name\n            } else if (\n              t.isFunctionExpression(splitNode) ||\n              t.isArrowFunctionExpression(splitNode)\n            ) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    splitNode as any,\n                  ),\n                ]),\n              )\n            } else if (\n              t.isImportSpecifier(splitNode) ||\n              t.isImportDefaultSpecifier(splitNode)\n            ) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    splitNode.local,\n                  ),\n                ]),\n              )\n            } else if (t.isVariableDeclarator(splitNode)) {\n              if (t.isIdentifier(splitNode.id)) {\n                splitMeta.localExporterIdent = splitNode.id.name\n                splitMeta.shouldRemoveNode = false\n              } else if (t.isObjectPattern(splitNode.id)) {\n                // Destructured binding like `const { component: MyComp } = createBits()`\n                // Use the original identifier name that was tracked before resolving\n                if (originalIdentName) {\n                  splitMeta.localExporterIdent = originalIdentName\n                }\n                splitMeta.shouldRemoveNode = false\n              } else {\n                throw new Error(\n                  `Unexpected splitNode type ☝️: ${splitNode.type}`,\n                )\n              }\n            } else if (t.isCallExpression(splitNode)) {\n              const outputSplitNodeCode = generateFromAst(splitNode).code\n              const splitNodeAst = babel.parse(outputSplitNodeCode)\n\n              if (!splitNodeAst) {\n                throw new Error(\n                  `Failed to parse the generated code for \"${SPLIT_TYPE}\" in the node type \"${splitNode.type}\"`,\n                )\n              }\n\n              const statement = splitNodeAst.program.body[0]\n\n              if (!statement) {\n                throw new Error(\n                  `Failed to parse the generated code for \"${SPLIT_TYPE}\" in the node type \"${splitNode.type}\" as no statement was found in the program body`,\n                )\n              }\n\n              if (t.isExpressionStatement(statement)) {\n                const expression = statement.expression\n                programPath.pushContainer(\n                  'body',\n                  t.variableDeclaration('const', [\n                    t.variableDeclarator(\n                      t.identifier(splitMeta.localExporterIdent),\n                      expression,\n                    ),\n                  ]),\n                )\n              } else {\n                throw new Error(\n                  `Unexpected expression type encounter for \"${SPLIT_TYPE}\" in the node type \"${splitNode.type}\"`,\n                )\n              }\n            } else if (t.isConditionalExpression(splitNode)) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    splitNode,\n                  ),\n                ]),\n              )\n            } else if (t.isTSAsExpression(splitNode)) {\n              // remove the type assertion\n              splitNode = splitNode.expression\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    splitNode,\n                  ),\n                ]),\n              )\n            } else if (t.isBooleanLiteral(splitNode)) {\n              // Handle boolean literals\n              // This exits early here, since this value will be kept in the reference file\n              return\n            } else if (t.isNullLiteral(splitNode)) {\n              // Handle null literals\n              // This exits early here, since this value will be kept in the reference file\n              return\n            } else {\n              console.info('Unexpected splitNode type:', splitNode)\n              throw new Error(`Unexpected splitNode type ☝️: ${splitNode.type}`)\n            }\n          }\n\n          if (splitMeta.shouldRemoveNode) {\n            // If the splitNode exists at the top of the program\n            // then we need to remove that copy\n            programPath.node.body = programPath.node.body.filter((node) => {\n              return node !== splitNode\n            })\n          }\n\n          // Export the node\n          programPath.pushContainer('body', [\n            t.exportNamedDeclaration(null, [\n              t.exportSpecifier(\n                t.identifier(splitMeta.localExporterIdent), // local variable name\n                t.identifier(splitMeta.exporterIdent), // as what name it should be exported as\n              ),\n            ]),\n          ])\n        })\n\n        // convert exports to imports from the original file\n        programPath.traverse({\n          ExportNamedDeclaration(path) {\n            // e.g. export const x = 1 or export { x }\n            // becomes\n            // import { x } from '${opts.id}'\n\n            if (path.node.declaration) {\n              if (t.isVariableDeclaration(path.node.declaration)) {\n                const specifiers = path.node.declaration.declarations.flatMap(\n                  (decl) => {\n                    if (t.isIdentifier(decl.id)) {\n                      return [\n                        t.importSpecifier(\n                          t.identifier(decl.id.name),\n                          t.identifier(decl.id.name),\n                        ),\n                      ]\n                    }\n\n                    if (t.isObjectPattern(decl.id)) {\n                      return collectIdentifiersFromPattern(decl.id).map(\n                        (name) =>\n                          t.importSpecifier(\n                            t.identifier(name),\n                            t.identifier(name),\n                          ),\n                      )\n                    }\n\n                    if (t.isArrayPattern(decl.id)) {\n                      return collectIdentifiersFromPattern(decl.id).map(\n                        (name) =>\n                          t.importSpecifier(\n                            t.identifier(name),\n                            t.identifier(name),\n                          ),\n                      )\n                    }\n\n                    return []\n                  },\n                )\n\n                if (specifiers.length === 0) {\n                  path.remove()\n                  return\n                }\n\n                const importDecl = t.importDeclaration(\n                  specifiers,\n                  t.stringLiteral(\n                    removeSplitSearchParamFromFilename(opts.filename),\n                  ),\n                )\n\n                path.replaceWith(importDecl)\n\n                // Track the imported identifier paths so deadCodeElimination can remove them if unused\n                // We need to traverse the newly created import to get the identifier paths\n                path.traverse({\n                  Identifier(identPath) {\n                    // Only track the local binding identifiers (the imported names)\n                    if (\n                      identPath.parentPath.isImportSpecifier() &&\n                      identPath.key === 'local'\n                    ) {\n                      refIdents.add(identPath)\n                    }\n                  },\n                })\n              }\n            }\n          },\n        })\n\n        // Add shared bindings import, registering specifiers in refIdents\n        // so DCE can remove unused ones (same pattern as import replacements above).\n        if (opts.sharedBindings && opts.sharedBindings.size > 0) {\n          const sharedImportSpecifiers = [...opts.sharedBindings].map((name) =>\n            t.importSpecifier(t.identifier(name), t.identifier(name)),\n          )\n          const sharedModuleUrl = addSharedSearchParamToFilename(\n            removeSplitSearchParamFromFilename(opts.filename),\n          )\n          const [sharedImportPath] = programPath.unshiftContainer(\n            'body',\n            t.importDeclaration(\n              sharedImportSpecifiers,\n              t.stringLiteral(sharedModuleUrl),\n            ),\n          )\n\n          sharedImportPath.traverse({\n            Identifier(identPath) {\n              if (\n                identPath.parentPath.isImportSpecifier() &&\n                identPath.key === 'local'\n              ) {\n                refIdents.add(identPath)\n              }\n            },\n          })\n        }\n      },\n    },\n  })\n\n  deadCodeElimination(ast, refIdents)\n\n  // Strip top-level expression statements that reference no locally-bound names.\n  // DCE only removes unused declarations; bare side-effect statements like\n  // `console.log(...)` survive even when the virtual file has no exports.\n  {\n    const locallyBound = new Set<string>()\n    for (const stmt of ast.program.body) {\n      collectLocalBindingsFromStatement(stmt, locallyBound)\n    }\n    ast.program.body = ast.program.body.filter((stmt) => {\n      if (!t.isExpressionStatement(stmt)) return true\n      const refs = collectIdentifiersFromNode(stmt)\n      // Keep if it references at least one locally-bound identifier\n      return [...refs].some((name) => locallyBound.has(name))\n    })\n  }\n\n  // If the body is empty after DCE, strip directive prologues too.\n  // A file containing only `'use client'` with no real code is useless.\n  if (ast.program.body.length === 0) {\n    ast.program.directives = []\n  }\n\n  const result = generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n\n  // @babel/generator does not populate sourcesContent — see compileCodeSplitReferenceRoute.\n  if (result.map) {\n    result.map.sourcesContent = [opts.code]\n  }\n\n  return result\n}\n\n/**\n * Compile the shared virtual module (`?tsr-shared=1`).\n * Keeps only shared binding declarations, their transitive dependencies,\n * and imports they need. Exports all shared bindings.\n */\nexport function compileCodeSplitSharedRoute(\n  opts: ParseAstOptions & {\n    sharedBindings: Set<string>\n    filename: string\n  },\n): GeneratorResult {\n  const ast = parseAst(opts)\n  const refIdents = findReferencedIdentifiers(ast)\n\n  // Collect all names that need to stay: shared bindings + their transitive deps\n  const localBindings = new Set<string>()\n  for (const node of ast.program.body) {\n    collectLocalBindingsFromStatement(node, localBindings)\n  }\n\n  // Route must never be extracted into the shared module.\n  // Excluding it from the dep graph prevents expandTransitively from\n  // pulling it in as a transitive dependency of a shared binding.\n  localBindings.delete('Route')\n\n  const declMap = buildDeclarationMap(ast)\n  const depGraph = buildDependencyGraph(declMap, localBindings)\n\n  // Start with shared bindings and expand transitively\n  const keepBindings = new Set(opts.sharedBindings)\n  keepBindings.delete('Route')\n  expandTransitively(keepBindings, depGraph)\n\n  // Remove all statements except:\n  // - Import declarations (needed for deps; DCE will clean unused ones)\n  // - Declarations of bindings in keepBindings\n  ast.program.body = ast.program.body.filter((stmt) => {\n    // Always keep imports — DCE will remove unused ones\n    if (t.isImportDeclaration(stmt)) return true\n\n    const decl =\n      t.isExportNamedDeclaration(stmt) && stmt.declaration\n        ? stmt.declaration\n        : stmt\n\n    if (t.isVariableDeclaration(decl)) {\n      // Keep declarators where at least one binding is in keepBindings\n      decl.declarations = decl.declarations.filter((declarator) => {\n        const names = collectIdentifiersFromPattern(declarator.id)\n        return names.some((n) => keepBindings.has(n))\n      })\n      if (decl.declarations.length === 0) return false\n\n      // Strip the `export` wrapper — shared module controls its own exports\n      if (t.isExportNamedDeclaration(stmt) && stmt.declaration) {\n        return true // keep for now, we'll convert below\n      }\n      return true\n    } else if (t.isFunctionDeclaration(decl) && decl.id) {\n      return keepBindings.has(decl.id.name)\n    } else if (t.isClassDeclaration(decl) && decl.id) {\n      return keepBindings.has(decl.id.name)\n    }\n\n    // Remove everything else (expression statements, other exports, etc.)\n    return false\n  })\n\n  // Convert `export const/function/class` to plain declarations\n  // (we'll add our own export statement at the end)\n  ast.program.body = ast.program.body.map((stmt) => {\n    if (t.isExportNamedDeclaration(stmt) && stmt.declaration) {\n      return stmt.declaration\n    }\n    return stmt\n  })\n\n  // Export all shared bindings (sorted for deterministic output)\n  const exportNames = [...opts.sharedBindings].sort((a, b) =>\n    a.localeCompare(b),\n  )\n  const exportSpecifiers = exportNames.map((name) =>\n    t.exportSpecifier(t.identifier(name), t.identifier(name)),\n  )\n  if (exportSpecifiers.length > 0) {\n    const exportDecl = t.exportNamedDeclaration(null, exportSpecifiers)\n    ast.program.body.push(exportDecl)\n\n    // Register export specifier locals in refIdents so DCE doesn't treat\n    // the exported bindings as unreferenced.\n    babel.traverse(ast, {\n      Program(programPath) {\n        const bodyPaths = programPath.get('body')\n        const last = bodyPaths[bodyPaths.length - 1]\n        if (last && last.isExportNamedDeclaration()) {\n          last.traverse({\n            Identifier(identPath) {\n              if (\n                identPath.parentPath.isExportSpecifier() &&\n                identPath.key === 'local'\n              ) {\n                refIdents.add(identPath)\n              }\n            },\n          })\n        }\n        programPath.stop()\n      },\n    })\n  }\n\n  deadCodeElimination(ast, refIdents)\n\n  // If the body is empty after DCE, strip directive prologues too.\n  if (ast.program.body.length === 0) {\n    ast.program.directives = []\n  }\n\n  const result = generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n\n  // @babel/generator does not populate sourcesContent — see compileCodeSplitReferenceRoute.\n  if (result.map) {\n    result.map.sourcesContent = [opts.code]\n  }\n\n  return result\n}\n\n/**\n * This function should read get the options from by searching for the key `codeSplitGroupings`\n * on createFileRoute and return it's values if it exists, else return undefined\n */\nexport function detectCodeSplitGroupingsFromRoute(opts: ParseAstOptions): {\n  groupings: CodeSplitGroupings | undefined\n} {\n  const ast = parseAst(opts)\n\n  let codeSplitGroupings: CodeSplitGroupings | undefined = undefined\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath) {\n        programPath.traverse({\n          CallExpression(path) {\n            if (!t.isIdentifier(path.node.callee)) {\n              return\n            }\n\n            if (\n              !(\n                path.node.callee.name === 'createRoute' ||\n                path.node.callee.name === 'createFileRoute'\n              )\n            ) {\n              return\n            }\n\n            function babelHandleSplittingGroups(\n              routeOptions: t.Node | undefined,\n            ) {\n              if (t.isObjectExpression(routeOptions)) {\n                routeOptions.properties.forEach((prop) => {\n                  if (t.isObjectProperty(prop)) {\n                    if (t.isIdentifier(prop.key)) {\n                      if (prop.key.name === 'codeSplitGroupings') {\n                        const value = prop.value\n\n                        if (t.isArrayExpression(value)) {\n                          codeSplitGroupings = value.elements.map((group) => {\n                            if (t.isArrayExpression(group)) {\n                              return group.elements.map((node) => {\n                                if (!t.isStringLiteral(node)) {\n                                  throw new Error(\n                                    'You must provide a string literal for the codeSplitGroupings',\n                                  )\n                                }\n\n                                return node.value\n                              }) as Array<SplitRouteIdentNodes>\n                            }\n\n                            throw new Error(\n                              'You must provide arrays with codeSplitGroupings options.',\n                            )\n                          })\n                        } else {\n                          throw new Error(\n                            'You must provide an array of arrays for the codeSplitGroupings.',\n                          )\n                        }\n                      }\n                    }\n                  }\n                })\n              }\n            }\n\n            // Extracting the codeSplitGroupings\n            if (t.isCallExpression(path.parentPath.node)) {\n              // createFileRoute('/')({ ... })\n              const options = resolveIdentifier(\n                path,\n                path.parentPath.node.arguments[0],\n              )\n\n              babelHandleSplittingGroups(options)\n            } else if (t.isVariableDeclarator(path.parentPath.node)) {\n              // createFileRoute({ ... })\n              const caller = resolveIdentifier(path, path.parentPath.node.init)\n\n              if (t.isCallExpression(caller)) {\n                const options = resolveIdentifier(path, caller.arguments[0])\n                babelHandleSplittingGroups(options)\n              }\n            }\n          },\n        })\n      },\n    },\n  })\n\n  return { groupings: codeSplitGroupings }\n}\n\nfunction createNotExportableMessage(\n  filename: string,\n  idents: Set<string>,\n): string {\n  const list = Array.from(idents).map((d) => `- ${d}`)\n\n  const message = [\n    `[tanstack-router] These exports from \"${filename}\" will not be code-split and will increase your bundle size:`,\n    ...list,\n    'For the best optimization, these items should either have their export statements removed, or be imported from another location that is not a route file.',\n  ].join('\\n')\n\n  return message\n}\n\nfunction getImportSpecifierAndPathFromLocalName(\n  programPath: babel.NodePath<t.Program>,\n  name: string,\n): {\n  specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null\n  path: string | null\n} {\n  let specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null = null\n  let path: string | null = null\n\n  programPath.traverse({\n    ImportDeclaration(importPath) {\n      const found = importPath.node.specifiers.find(\n        (targetSpecifier) => targetSpecifier.local.name === name,\n      )\n      if (found) {\n        specifier = found\n        path = importPath.node.source.value\n      }\n    },\n  })\n\n  return { specifier, path }\n}\n\n/**\n * Recursively collects all identifier names from a destructuring pattern\n * (ObjectPattern, ArrayPattern, AssignmentPattern, RestElement).\n */\nfunction collectIdentifiersFromPattern(\n  node: t.LVal | t.Node | null | undefined,\n): Array<string> {\n  if (!node) {\n    return []\n  }\n\n  if (t.isIdentifier(node)) {\n    return [node.name]\n  }\n\n  if (t.isAssignmentPattern(node)) {\n    return collectIdentifiersFromPattern(node.left)\n  }\n\n  if (t.isRestElement(node)) {\n    return collectIdentifiersFromPattern(node.argument)\n  }\n\n  if (t.isObjectPattern(node)) {\n    return node.properties.flatMap((prop) => {\n      if (t.isObjectProperty(prop)) {\n        return collectIdentifiersFromPattern(prop.value as t.LVal)\n      }\n      if (t.isRestElement(prop)) {\n        return collectIdentifiersFromPattern(prop.argument)\n      }\n      return []\n    })\n  }\n\n  if (t.isArrayPattern(node)) {\n    return node.elements.flatMap((element) =>\n      collectIdentifiersFromPattern(element),\n    )\n  }\n\n  return []\n}\n\n// Reusable function to get literal value or resolve variable to literal\nfunction resolveIdentifier(path: any, node: any): t.Node | undefined {\n  if (t.isIdentifier(node)) {\n    const binding = path.scope.getBinding(node.name)\n    if (\n      binding\n      // && binding.kind === 'const'\n    ) {\n      const declarator = binding.path.node\n      if (t.isObjectExpression(declarator.init)) {\n        return declarator.init\n      } else if (t.isFunctionDeclaration(declarator.init)) {\n        return declarator.init\n      }\n    }\n    return undefined\n  }\n\n  return node\n}\n\nfunction removeIdentifierLiteral(path: babel.NodePath, node: t.Identifier) {\n  const binding = path.scope.getBinding(node.name)\n  if (binding) {\n    // If the binding is a destructured property from an ObjectPattern,\n    // only remove that property instead of the entire declaration\n    if (\n      t.isVariableDeclarator(binding.path.node) &&\n      t.isObjectPattern(binding.path.node.id)\n    ) {\n      const objectPattern = binding.path.node.id\n      objectPattern.properties = objectPattern.properties.filter((prop) => {\n        if (!t.isObjectProperty(prop)) {\n          return true\n        }\n\n        if (t.isIdentifier(prop.value) && prop.value.name === node.name) {\n          return false\n        }\n\n        if (\n          t.isAssignmentPattern(prop.value) &&\n          t.isIdentifier(prop.value.left) &&\n          prop.value.left.name === node.name\n        ) {\n          return false\n        }\n\n        return true\n      })\n\n      // If no properties remain, remove the entire declaration\n      if (objectPattern.properties.length === 0) {\n        binding.path.remove()\n      }\n\n      return\n    }\n\n    binding.path.remove()\n  }\n}\n\nfunction hasExport(ast: t.File, node: t.Identifier): boolean {\n  let found = false\n\n  babel.traverse(ast, {\n    ExportNamedDeclaration(path) {\n      if (path.node.declaration) {\n        // declared as `const loaderFn = () => {}`\n        if (t.isVariableDeclaration(path.node.declaration)) {\n          path.node.declaration.declarations.forEach((decl) => {\n            if (t.isVariableDeclarator(decl)) {\n              if (t.isIdentifier(decl.id)) {\n                if (decl.id.name === node.name) {\n                  found = true\n                }\n              } else if (\n                t.isObjectPattern(decl.id) ||\n                t.isArrayPattern(decl.id)\n              ) {\n                // Handle destructured exports like `export const { a, b } = fn()`\n                const names = collectIdentifiersFromPattern(decl.id)\n                if (names.includes(node.name)) {\n                  found = true\n                }\n              }\n            }\n          })\n        }\n\n        // declared as `function loaderFn() {}`\n        if (t.isFunctionDeclaration(path.node.declaration)) {\n          if (t.isIdentifier(path.node.declaration.id)) {\n            if (path.node.declaration.id.name === node.name) {\n              found = true\n            }\n          }\n        }\n      }\n    },\n    ExportDefaultDeclaration(path) {\n      // declared as `export default loaderFn`\n      if (t.isIdentifier(path.node.declaration)) {\n        if (path.node.declaration.name === node.name) {\n          found = true\n        }\n      }\n\n      // declared as `export default function loaderFn() {}`\n      if (t.isFunctionDeclaration(path.node.declaration)) {\n        if (t.isIdentifier(path.node.declaration.id)) {\n          if (path.node.declaration.id.name === node.name) {\n            found = true\n          }\n        }\n      }\n    },\n  })\n\n  return found\n}\n\nfunction removeExports(ast: t.File, node: t.Identifier): boolean {\n  let removed = false\n\n  // The checks use sequential if/else if statements since it\n  // directly mutates the AST and as such doing normal checks\n  // (using only if statements) could lead to a situation where\n  // `path.node` is null since it has been already removed from\n  // the program tree but typescript doesn't know that.\n  babel.traverse(ast, {\n    ExportNamedDeclaration(path) {\n      if (path.node.declaration) {\n        if (t.isVariableDeclaration(path.node.declaration)) {\n          // declared as `const loaderFn = () => {}`\n          path.node.declaration.declarations.forEach((decl) => {\n            if (t.isVariableDeclarator(decl)) {\n              if (t.isIdentifier(decl.id)) {\n                if (decl.id.name === node.name) {\n                  path.remove()\n                  removed = true\n                }\n              } else if (\n                t.isObjectPattern(decl.id) ||\n                t.isArrayPattern(decl.id)\n              ) {\n                // Handle destructured exports like `export const { a, b } = fn()`\n                const names = collectIdentifiersFromPattern(decl.id)\n                if (names.includes(node.name)) {\n                  path.remove()\n                  removed = true\n                }\n              }\n            }\n          })\n        } else if (t.isFunctionDeclaration(path.node.declaration)) {\n          // declared as `export const loaderFn = () => {}`\n          if (t.isIdentifier(path.node.declaration.id)) {\n            if (path.node.declaration.id.name === node.name) {\n              path.remove()\n              removed = true\n            }\n          }\n        }\n      }\n    },\n    ExportDefaultDeclaration(path) {\n      // declared as `export default loaderFn`\n      if (t.isIdentifier(path.node.declaration)) {\n        if (path.node.declaration.name === node.name) {\n          path.remove()\n          removed = true\n        }\n      } else if (t.isFunctionDeclaration(path.node.declaration)) {\n        // declared as `export default function loaderFn() {}`\n        if (t.isIdentifier(path.node.declaration.id)) {\n          if (path.node.declaration.id.name === node.name) {\n            path.remove()\n            removed = true\n          }\n        }\n      }\n    },\n  })\n\n  return removed\n}\n"],"names":["opts"],"mappings":"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"}